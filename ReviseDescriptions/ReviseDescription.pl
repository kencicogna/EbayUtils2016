#!/usr/bin/perl -w 
# generated by wxGlade 0.6.5 (standalone edition) on Fri Nov 30 13:55:30 2012
# To get wxPerl visit http://wxPerl.sourceforge.net/

use strict;
use LWP::UserAgent;
use LWP::Simple;
use HTTP::Request;
use HTTP::Headers;
use HTML::Restrict;
use Encode;
use Text::Unidecode;
use DBI;
use XML::Simple qw(XMLin XMLout);
# use XML::Tidy;
use Date::Calc 'Today';
use Data::Dumper 'Dumper';			$Data::Dumper::Sortkeys = 1;
use File::Copy qw(copy move);
use POSIX;
use Getopt::Std;
use Storable 'dclone';
use Fatal qw(open close);

use lib '../cfg';
use EbayConfig;


my %opts;
getopts('i:raDAf',\%opts);
# -i <ebay item ID>		- perform operations on this single item
# -a                  - perform operations on all items
# -r 									- revise item(s)
# -D                  - Debug/verbose mode. 
# -f                  - force rerun, even if item id has already been processed
my @item_list;
my $process_all_items = 0;

if ( defined $opts{i} ) {
	@item_list = split(',',$opts{i});
}
elsif ( defined $opts{a} ) {
  $process_all_items = 1;
}
else {
	die "must supply either option '-i <item id>' or '-a' option";
}

my $REVISE_ITEM = defined $opts{r} ? 1 : 0;
my $DEBUG       = defined $opts{D} ? 1 : 0;
my $force       = defined $opts{f} ? 1 : 0;

my $html_filter = HTML::Restrict->new(
        rules => {
            p  => [],
            ul => [],
            li => [],
            br => [],
            div => [],
        }
    );


###################################################
# EBAY API INFO                                   #
###################################################

# Ebay API Request Headers
my $header = $EbayConfig::ES_http_header;

# Ebay Authentication Token
my $eBayAuthToken = $EbayConfig::ES_eBayAuthToken;


my $request_getitem_default = <<END_XML;
<?xml version='1.0' encoding='utf-8'?>
<GetItemRequest xmlns="urn:ebay:apis:eBLBaseComponents">
  <RequesterCredentials>
    <eBayAuthToken>$eBayAuthToken</eBayAuthToken>
  </RequesterCredentials>
  <WarningLevel>High</WarningLevel>
  <DetailLevel>ReturnAll</DetailLevel>
  <ItemID>__ItemID__</ItemID>
  <OutputSelector>ItemID</OutputSelector>
  <OutputSelector>Site</OutputSelector>
  <OutputSelector>Title</OutputSelector>
  <OutputSelector>Description</OutputSelector>
</GetItemRequest>
END_XML

#  <IncludeItemSpecifics>TRUE</IncludeItemSpecifics>

my $request_getmyebayselling = <<END_XML;
<?xml version='1.0' encoding='utf-8'?>
<GetMyeBaySellingRequest xmlns="urn:ebay:apis:eBLBaseComponents">
<RequesterCredentials>
  <eBayAuthToken>$eBayAuthToken</eBayAuthToken>
</RequesterCredentials>
<WarningLevel>High</WarningLevel>
<ActiveList>
	<Include>true</Include>
	<Pagination>
		<EntriesPerPage>200</EntriesPerPage>
		<PageNumber>__PAGE_NUMBER__</PageNumber>
	</Pagination>
</ActiveList>
</GetMyeBaySellingRequest>
END_XML

my $request_reviseitem_default = <<END_XML;
<?xml version='1.0' encoding='utf-8'?>
<ReviseFixedPriceItemRequest xmlns="urn:ebay:apis:eBLBaseComponents">
<RequesterCredentials>
  <eBayAuthToken>$eBayAuthToken</eBayAuthToken>
</RequesterCredentials>
<WarningLevel>High</WarningLevel>
<Item>
  <ItemID>__ItemID__</ItemID>
  <DescriptionReviseMode>Replace</DescriptionReviseMode>
  <Description>
__DESCRIPTION__
  </Description>
</Item>
</ReviseFixedPriceItemRequest>
END_XML


###########################################################
# END EBAY API INFO                                       #
###########################################################

my $request;
my $response_hash;

################################################################################
# Get list of all item ids
################################################################################
my @all_items;
my $pagenumber=1;
my $maxpages=1000000;

if ( ! $process_all_items ) {
	push(@all_items,@item_list);
}
else {

  while ( $pagenumber <= $maxpages ) {
    $request = $request_getmyebayselling;
    $request =~ s/__PAGE_NUMBER__/$pagenumber/;
    $response_hash = submit_request( 'GetMyeBaySelling', $request, $header );

    for my $i ( @{$response_hash->{ActiveList}->{ItemArray}->{Item}} ) {

      # NOTE: Exclude foreign listings by currency (not perfect, some other countries could use USD)
      #       But, by doing a check here, we avoid a lot of extra API calls later 
      #       The foreign listing are created by a third party and already have teh viewport tag.
      next if ($i->{SellingStatus}->{CurrentPrice}->{currencyID} ne 'USD');

      push(@all_items, $i->{ItemID});
    }

    if ($pagenumber==1) {
      $maxpages = $response_hash->{ActiveList}->{PaginationResult}->{TotalNumberOfPages};
    }
    $pagenumber++;
  }

}

my $all_items_count = scalar @all_items;

my $bkp_dir = "html_backup";
if ( ! -d $bkp_dir ) {
  mkdir $bkp_dir;
}


################################################################################
# Loop over each item (active on eBay)
################################################################################
for my $item_id ( reverse @all_items ) {

  # Skip this is if already processed
  my $bkp_file = "$bkp_dir/${item_id}.html";
  if ( ! -e  $bkp_file || $force ) {
    print "\nStarting $item_id";
  }
  else {
    print "\nSkipping $item_id";
    next;
  }

  # Get detailed info from ebay on this itemID
  $request = $request_getitem_default;
  $request =~ s/__ItemID__/$item_id/;

  my $ebayResponse = submit_request( 'GetItem', $request, $header );
  my $ebayListing = $ebayResponse->{Item};
  my $title       = $ebayListing->{Title};
  my $raw_html    = $ebayListing->{Description};
  my $site        = $ebayListing->{Site};

  print "\n",Dumper($ebayListing) if $DEBUG;

  # Exclude foreign listing (the foreign listing are created by a third party and already have teh viewport tag)
  if ( $site ne 'US' ) {
    print " ....skipping foreign listing";
    next;
  }

  # Save the current html as a backup
  open my $fh, '>', $bkp_file;
  print $fh $raw_html;     
  close $fh;

  my $description = parse_description_html( $ebayListing );

  if ( ! $description ) {
    die qq/\n$item_id,"$title","ERROR: No description after parsing!"/;
  }

  # Add mobile friendly html display tag
  $description = '<meta name="viewport" content="width=device-width, initial-scale=1">' . "\n" . $description;

  print Dumper($description) if $DEBUG;

  # Save new html for debugging
  if ( $DEBUG ) {
    open my $fh, '>', "${item_id}.new.html";
    print $fh $description;     
    close $fh;
  }

  #
  # Revise listing with new description
  #
  if ( $REVISE_ITEM ) {
    $request = $request_reviseitem_default;
    $request =~ s/__ItemID__/$item_id/;
    $request =~ s/__DESCRIPTION__/<![CDATA[$description]]>/;

    my $r;
		eval {
      $r = submit_request( 'ReviseFixedPriceItem', $request, $header );
		};
		if ( $@ ) {
      # Print errors
			print qq/$item_id,"$title","ERROR: Submit ReviseFixedPriceItem failed. $@"\n/;
			next;
		}
    # Print warnings
    if ( $r->{LongMessage} ) {
      print qq/\n$item_id,"$title","$r->{LongMessage}"/;
    }
  }

}

print "\n\n";
exit;

####################################################################################################

sub parse_description_html {
  my $listing = shift;
  my $html    = unidecode( $listing->{Description} );
  my $desc;

  die "\n\nERROR: NO 'Description' key in the ebayListing hash!"
    if ( ! $html );

  $desc = $html_filter->process( $html );

  $desc =~ s/<li>\s+([^\s]+)/<li>$1/igms;              # TODO: verify this works

  print STDERR "\nERROR  : DESCRIPTION NOT FOUND   for title: '$listing->{Title}" if ( ! $desc );
  print STDERR "\nWARNING: DESCRIPTION > 2000 chars for title: '$listing->{Title}" if ( length($desc) > 2000 );

  return $desc;
}


sub submit_request {
	my ($call_name, $request, $objHeader) = @_;
  my ($objRequest, $objUserAgent, $objResponse);
  my $request_sent_attempts = 0;

	$header->remove_header('X-EBAY-API-CALL-NAME');
	$header->push_header  ('X-EBAY-API-CALL-NAME' => $call_name);

  RESEND_REQUEST:
  $request_sent_attempts++;

  # Create UserAgent and Request objects
  $objUserAgent = LWP::UserAgent->new;
  $objRequest   = HTTP::Request->new(
    "POST",
    "https://api.ebay.com/ws/api.dll",
    $objHeader,
    $request
  );

	#print "\n objHeader : ",Dumper($objHeader);
	#print "\n request   : ",Dumper($request);
	#print "\n objRequest: ",Dumper($objRequest);

  # Submit Request
  $objResponse = $objUserAgent->request($objRequest);		# SEND REQUEST

  # Parse Response object to get Acknowledgement 
	my $content =  $objResponse->content;
	my $response_hash = XMLin( "$content",  
      ForceArray=>['InternationalShippingServiceOption','ShippingServiceOptions','ShipToLocation','Variation','NameValueList','Errors' ] );
	#my $response_hash = XMLin( $content );
  my $ack = $response_hash->{Ack};

  my $errors_found;
  if ( defined $response_hash->{Errors} ) {
    for my $e ( @{ $response_hash->{Errors} } ) {
      if ( $e->{SeverityCode} ne "Warning" ) {
        $errors_found++;
      }
    }
  }

  if ( (!$objResponse->is_error && $ack =~ /success/i) or ! $errors_found ) {
    return $response_hash;
  }
  else {
		print "\n\n";
    print  "Response msg.   : ", Dumper( $response_hash->{Errors} );
    print  "Status          : FAILED";
    print  $objResponse->error_as_HTML;

    # Resend update request
    if ( $request_sent_attempts < 1 ) {
      print  "Attempting to resend update request.\n";
      goto RESEND_REQUEST;
    }

		die;
  }

} # end submit_request()

